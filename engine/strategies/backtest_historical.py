"""
Historical Backtest Script for ROCMeanReversionStrategy

Fetches 1-week of 1h ETHUSDT perpetual futures data from Binance,
runs the strategy, and exports all signals with full details to CSV.
"""

import csv
import os
from datetime import datetime, timedelta, timezone
from dataclasses import dataclass
from typing import List, Optional

from binance.client import Client

from engine.market_data.candle import MidPriceCandle
from engine.strategies.roc_mean_reversion_strategy import (
    ROCMeanReversionStrategy,
    ROCMeanReversionStrategyConfig,
)
from engine.strategies.models import Position, PositionSide


@dataclass
class SignalRecord:
    """Record of a signal generated by the strategy."""

    timestamp: datetime
    open: float
    high: float
    low: float
    close: float
    volume: float
    signal: int  # 1=BUY, -1=SELL, 0=CLOSE
    reason: str
    roc_value: float
    position_state: str  # FLAT, LONG, SHORT
    stop_loss_price: Optional[float]


class SignalLoggingOrderManager:
    """
    Mock order manager that logs signals instead of executing them.
    Captures all signal details for CSV export.
    Also updates the strategy's position cache to enable proper signal flow.
    """

    def __init__(self, strategy: ROCMeanReversionStrategy):
        self._strategy = strategy  # Reference to strategy for position cache updates
        self.signals: List[SignalRecord] = []
        self._current_candle: Optional[MidPriceCandle] = None
        self._current_roc_value: float = 0.0
        self._current_volume: float = 0.0
        self._position_state: str = "FLAT"
        self._stop_loss_price: Optional[float] = None

    def set_current_context(
        self,
        candle: MidPriceCandle,
        roc_value: float,
        volume: float,
        position_state: str,
        stop_loss_price: Optional[float],
    ):
        """Set context for the current bar being processed."""
        self._current_candle = candle
        self._current_roc_value = roc_value
        self._current_volume = volume
        self._position_state = position_state
        self._stop_loss_price = stop_loss_price

    def on_signal(
        self,
        strategy_id: str,
        signal: int,
        price: float,
        symbol: str,
        strategy_actions,
        strategy_order_mode,
        tags: List[str] = None,
    ) -> bool:
        """Capture signal instead of executing order."""
        reason = self._extract_reason(tags)

        # Use candle close time (start + 1 hour) for accurate signal timing
        candle_close_time = self._current_candle.start_time + timedelta(hours=1)

        record = SignalRecord(
            timestamp=candle_close_time,
            open=self._current_candle.open or 0.0,
            high=self._current_candle.high if self._current_candle.high != float("-inf") else 0.0,
            low=self._current_candle.low if self._current_candle.low != float("inf") else 0.0,
            close=self._current_candle.close or 0.0,
            volume=self._current_volume,
            signal=signal,
            reason=reason if reason else ("LONG ENTRY" if signal == 1 else "SHORT ENTRY"),
            roc_value=self._current_roc_value,
            position_state=self._position_state,
            stop_loss_price=self._stop_loss_price,
        )
        self.signals.append(record)

        # Update position state after signal AND update strategy's cache
        if signal == 1:  # BUY/LONG
            self._position_state = "LONG"
            position = Position(
                instrument_id=symbol,
                side=PositionSide.LONG,
                quantity=1.0,
                entry_price=price,
            )
            self._strategy.cache.update_position(position)
        elif signal == -1:  # SELL/SHORT
            self._position_state = "SHORT"
            position = Position(
                instrument_id=symbol,
                side=PositionSide.SHORT,
                quantity=1.0,
                entry_price=price,
            )
            self._strategy.cache.update_position(position)

        return True

    def submit_market_close(
        self,
        strategy_id: str,
        symbol: str,
        price: float,
        tags: List[str] = None,
    ) -> bool:
        """Capture close signal."""
        reason = self._extract_reason(tags)

        # Use candle close time (start + 1 hour) for accurate signal timing
        candle_close_time = self._current_candle.start_time + timedelta(hours=1)

        record = SignalRecord(
            timestamp=candle_close_time,
            open=self._current_candle.open or 0.0,
            high=self._current_candle.high if self._current_candle.high != float("-inf") else 0.0,
            low=self._current_candle.low if self._current_candle.low != float("inf") else 0.0,
            close=self._current_candle.close or 0.0,
            volume=self._current_volume,
            signal=0,  # CLOSE
            reason=reason if reason else "CLOSE POSITION",
            roc_value=self._current_roc_value,
            position_state=self._position_state,
            stop_loss_price=self._stop_loss_price,
        )
        self.signals.append(record)

        # Reset position state after close AND update strategy's cache
        self._position_state = "FLAT"
        self._stop_loss_price = None

        # Clear position in strategy cache
        flat_position = Position(
            instrument_id=symbol,
            side=PositionSide.FLAT,
            quantity=0,
            entry_price=0,
        )
        self._strategy.cache.update_position(flat_position)

        return True

    def _extract_reason(self, tags: List[str] = None) -> str:
        """Extract reason from tags."""
        if not tags:
            return ""
        for tag in tags:
            if tag.startswith("reason="):
                return tag.replace("reason=", "")
        return ""


class HistoricalBacktester:
    """
    Backtester that fetches historical data and runs strategy.
    """

    def __init__(self, symbol: str = "ETHUSDT", interval: str = "1h"):
        self.symbol = symbol
        self.interval = interval
        self.client = Client()  # No API keys needed for public data
        self.candles: List[MidPriceCandle] = []
        self.volumes: List[float] = []

    def fetch_data(self, days: int = 8) -> int:
        """
        Fetch historical klines data from Binance Futures.

        Args:
            days: Number of days of historical data to fetch

        Returns:
            Number of candles fetched
        """
        # Calculate time range in UTC:
        # End: yesterday 23:59:59 UTC
        # Start: (days) days before today at 00:00:00 UTC
        now_utc = datetime.now(timezone.utc)
        today_start = now_utc.replace(hour=0, minute=0, second=0, microsecond=0)
        end_time = today_start - timedelta(seconds=1)  # Yesterday 23:59:59 UTC
        start_time = today_start - timedelta(days=days)  # 8 days ago 00:00:00 UTC

        print(f"Fetching {self.symbol} {self.interval} data...")
        print(f"  From: {start_time.strftime('%Y-%m-%d %H:%M:%S')} UTC")
        print(f"  To:   {end_time.strftime('%Y-%m-%d %H:%M:%S')} UTC")

        # Fetch klines from Binance Futures
        klines = self.client.futures_klines(
            symbol=self.symbol,
            interval=self.interval,
            startTime=int(start_time.timestamp() * 1000),
            endTime=int(end_time.timestamp() * 1000),
        )

        # Convert to MidPriceCandle objects
        self.candles = []
        self.volumes = []

        for kline in klines:
            # Kline format: [open_time, open, high, low, close, volume, close_time,
            #                quote_volume, trades, taker_buy_base, taker_buy_quote, ignore]
            open_time = datetime.fromtimestamp(kline[0] / 1000, tz=timezone.utc)

            candle = MidPriceCandle(start_time=open_time)
            candle.open = float(kline[1])
            candle.high = float(kline[2])
            candle.low = float(kline[3])
            candle.close = float(kline[4])

            self.candles.append(candle)
            self.volumes.append(float(kline[5]))

        print(f"  Fetched {len(self.candles)} candles")
        return len(self.candles)

    def run_strategy(self, strategy: ROCMeanReversionStrategy) -> List[SignalRecord]:
        """
        Run strategy on historical data and capture signals.

        Args:
            strategy: Strategy instance to run

        Returns:
            List of signal records
        """
        # Create mock order manager with reference to strategy for position cache updates
        order_manager = SignalLoggingOrderManager(strategy)

        # Wire up strategy
        strategy.set_order_manager(order_manager, "backtest", self.symbol)
        strategy.on_start()

        print(f"\nRunning {strategy.__class__.__name__}...")
        print(f"  ROC Period: {strategy.roc_period}")
        print(f"  ROC Upper: {strategy.roc_upper}")
        print(f"  ROC Lower: {strategy.roc_lower}")
        print(f"  ROC Mid: {strategy.roc_mid}")

        # Trace data for debugging (every bar's ROC values)
        self.trace_data: List[dict] = []

        # Process each candle
        for i, candle in enumerate(self.candles):
            # Capture previous_roc BEFORE processing (this is what strategy uses)
            previous_roc = strategy._previous_roc

            # Get current ROC value BEFORE this bar updates it
            roc_before = strategy.roc.value * 100 if strategy.roc.initialized else None

            # Determine position state
            if strategy.cache.is_flat(strategy.instrument_id):
                position_state = "FLAT"
            elif strategy.cache.is_net_long(strategy.instrument_id):
                position_state = "LONG"
            else:
                position_state = "SHORT"

            # Set context for signal logging
            order_manager.set_current_context(
                candle=candle,
                roc_value=previous_roc,  # Log the previous ROC (what's used for comparison)
                volume=self.volumes[i],
                position_state=position_state,
                stop_loss_price=strategy._stop_loss_price,
            )

            # Process candle (this updates ROC and may generate signals)
            strategy.on_candle_created(candle)

            # Capture current_roc AFTER processing (the newly calculated value)
            current_roc = strategy.roc.value * 100 if strategy.roc.initialized else None

            # Store trace data for every bar
            candle_close_time = candle.start_time + timedelta(hours=1)
            self.trace_data.append(
                {
                    "timestamp": candle_close_time.strftime("%Y-%m-%d %H:%M:%S"),
                    "close": candle.close,
                    "previous_roc": f"{previous_roc:.4f}" if previous_roc else "",
                    "current_roc": f"{current_roc:.4f}" if current_roc else "",
                    "position": position_state,
                }
            )

        strategy.on_stop()

        print(f"  Processed {len(self.candles)} candles")
        print(f"  Generated {len(order_manager.signals)} signals")

        return order_manager.signals

    def export_signals(self, signals: List[SignalRecord], output_dir: str = "reports") -> str:
        """
        Export signals to CSV file.

        Args:
            signals: List of signal records
            output_dir: Directory to save CSV file

        Returns:
            Path to created CSV file
        """
        # Ensure output directory exists
        os.makedirs(output_dir, exist_ok=True)

        # Generate filename with timestamp
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"ethusdt_backtest_signals_{timestamp}.csv"
        filepath = os.path.join(output_dir, filename)

        # Define CSV columns
        fieldnames = [
            "timestamp",
            "open",
            "high",
            "low",
            "close",
            "volume",
            "signal",
            "signal_name",
            "reason",
            "roc_value",
            "position_state",
            "stop_loss_price",
        ]

        # Write CSV
        with open(filepath, "w", newline="") as csvfile:
            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
            writer.writeheader()

            for record in signals:
                signal_name = {1: "BUY", -1: "SELL", 0: "CLOSE"}.get(record.signal, "UNKNOWN")

                writer.writerow(
                    {
                        "timestamp": record.timestamp.strftime("%Y-%m-%d %H:%M:%S"),
                        "open": f"{record.open:.4f}",
                        "high": f"{record.high:.4f}",
                        "low": f"{record.low:.4f}",
                        "close": f"{record.close:.4f}",
                        "volume": f"{record.volume:.4f}",
                        "signal": record.signal,
                        "signal_name": signal_name,
                        "reason": record.reason,
                        "roc_value": f"{record.roc_value:.4f}",
                        "position_state": record.position_state,
                        "stop_loss_price": (
                            f"{record.stop_loss_price:.4f}" if record.stop_loss_price else ""
                        ),
                    }
                )

        print(f"\nSignals exported to: {filepath}")
        return filepath

    def export_trace(self, output_dir: str = "reports") -> str:
        """
        Export full trace of all bars with ROC values for debugging.
        Compare this with Pine Script's ROC values to find discrepancies.
        """
        os.makedirs(output_dir, exist_ok=True)

        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"ethusdt_roc_trace_{timestamp}.csv"
        filepath = os.path.join(output_dir, filename)

        fieldnames = ["timestamp", "close", "previous_roc", "current_roc", "position"]

        with open(filepath, "w", newline="") as csvfile:
            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
            writer.writeheader()
            for row in self.trace_data:
                writer.writerow(row)

        print(f"ROC trace exported to: {filepath}")
        return filepath


def main():
    """Run historical backtest."""
    print("=" * 60)
    print("Historical Backtest: ROCMeanReversionStrategy")
    print("=" * 60)

    # Initialize backtester
    backtester = HistoricalBacktester(symbol="ETHUSDT", interval="1h")

    # Fetch 1 week of data
    backtester.fetch_data(days=8)

    # Create strategy with default config
    config = ROCMeanReversionStrategyConfig(
        instrument_id="ETHUSDT",
        bar_type="ETHUSDT-1h",
    )
    strategy = ROCMeanReversionStrategy(config)

    # Run strategy and capture signals
    signals = backtester.run_strategy(strategy)

    # Export to CSV
    csv_path = backtester.export_signals(signals)

    # Export ROC trace for debugging (compare with Pine Script)
    trace_path = backtester.export_trace()

    # Print summary
    print("\n" + "=" * 60)
    print("Summary")
    print("=" * 60)
    print(f"Total candles processed: {len(backtester.candles)}")
    print(f"Total signals generated: {len(signals)}")

    if signals:
        buy_signals = sum(1 for s in signals if s.signal == 1)
        sell_signals = sum(1 for s in signals if s.signal == -1)
        close_signals = sum(1 for s in signals if s.signal == 0)
        print(f"  BUY signals:   {buy_signals}")
        print(f"  SELL signals:  {sell_signals}")
        print(f"  CLOSE signals: {close_signals}")

    print(f"\nOutput file: {csv_path}")


if __name__ == "__main__":
    main()
