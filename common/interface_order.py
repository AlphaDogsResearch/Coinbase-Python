import loggingfrom abc import ABCfrom enum import Enumfrom common.recycle import Recyclablefrom common.seriallization import Serializable# Side of an order or tradeclass Side(Enum):    BUY = 0    SELL = 1# Order type indicates execution strategyclass OrderType(Enum):    Limit = 0    Market = 1    StopLimit = 2    StopMarket = 3    PostOnly = 4# Time in force indicates how long an order will remain active before it is executed or expired.class TimeInForce(Enum):    IOC = 1    GTC = 2# New order request# Note: post_only = True means the order will only make liquidity not take; False means it can make or take.class NewOrderSingle:    def __init__(self,                 client_id:str,                 symbol: str,                 side: Side,                 quantity: float,                 order_type: OrderType,                 price: float = None,                 post_only=False):        self.client_id = client_id        self.symbol = symbol        self.side = side        self.price = price        self.quantity = quantity        self.type = order_type        self.post_only = post_only    def __str__(self):        return "client_id=" + self.client_id + \                "symbol=" + self.symbol + \               ", side=" + str(self.side) + \               ", price=" + str(self.price) + \               ", quantity=" + str(self.quantity) + \               ", type=" + str(self.type) + \               ", post_only=" + str(self.post_only)# Execution typeclass ExecutionType(Enum):    NEW = 0    CANCELED = 1    CALCULATED = 2    EXPIRED = 3    TRADE = 4# Order statusclass OrderStatus(Enum):    PENDING_NEW = 0         # sent to exchange but has not received any status    NEW = 1                 # order accepted by exchange but not processed yet by the matching engine    OPEN = 2                # order accepted by exchange and is active on order book    CANCELED = 3            # order is cancelled    PARTIALLY_FILLED = 4    # order is partially filled    FILLED = 5              # order is fully filled and closed (i.e. not expecting any more fills)    PENDING_CANCEL = 6      # cancellation sent to exchange but has not received any status    FAILED = 7              # order failed# An executing orderclass Order(Serializable, Recyclable, ABC):    def __init__(self,                 order_id: str,                 side: Side,                 leaves_qty: float,                 symbol: str,                 timestamp: float,                 order_type: OrderType,                 price: float = None,                 order_status: OrderStatus = OrderStatus.PENDING_NEW,                 strategy_id: str = None):        self.order_id = order_id        self.side = side        self.quantity = leaves_qty        self.leaves_qty = leaves_qty        self.filled_qty = 0        self.symbol = symbol        self.timestamp = timestamp        self.price = price        self.avg_filled_price = 0        self.total_amount = 0        self.order_type = order_type        self.order_status = order_status        self.strategy_id = strategy_id        self.is_in_order_done_state = False    @classmethod    def create_base_order(cls, order_id: str):        return cls(order_id, None, 0, "", 0, None, None, OrderStatus.PENDING_NEW, None)    def update_order_fields(self,                            side: Side,                            leaves_qty: float,                            symbol: str,                            timestamp: float,                            price: float = None,                            strategy_id: str = None):        self.side = side        self.quantity = leaves_qty        self.leaves_qty = leaves_qty        self.symbol = symbol        self.timestamp = timestamp        self.price = price        self.strategy_id = strategy_id    def on_new_event(self):        if self.is_in_order_done_state:            logging.error(f"Order is in done state ,overfilled ?  current order status {self.order_status}")        self.order_status = OrderStatus.NEW    def on_filled_event(self,event_filled_quantity:float,event_filled_price:float) -> None:        if self.is_in_order_done_state:            logging.error(f"Order is in done state ,overfilled ?  current order status {self.order_status}")        self.leaves_qty -= event_filled_quantity        self.filled_qty += event_filled_quantity        # Calculate the cost of this new fill        new_cost = event_filled_quantity * event_filled_price        # Update the running totals        self.total_amount += new_cost        # Recalculate the new average price        self.avg_filled_price = self.total_amount / self.filled_qty        if self.leaves_qty == 0:            self.order_status = OrderStatus.FILLED            self.is_in_order_done_state = True        else:            self.order_status = OrderStatus.PARTIALLY_FILLED        logging.info(f"On Filled Event "                     f"leave_qty {self.leaves_qty},"                     f"filled_qty {self.filled_qty},"                     f"avg_filled_price {self.avg_filled_price}, "                     f"order_status {self.order_status}"                     )    def on_order_cancel_event(self):        if self.is_in_order_done_state:            logging.error(f"Unable to be cancelled ,Order is in done state , current order status {self.order_status}")        self.order_status = OrderStatus.CANCELED        self.leaves_qty = 0        self.avg_filled_price = 0        self.is_in_order_done_state = True    def recycle(self):        self.order_id = ""        self.side = None        self.quantity = 0        self.leaves_qty = 0        self.filled_qty = 0        self.symbol = ""        self.timestamp = 0        self.price = None        self.avg_filled_price = 0        self.total_amount = 0        self.order_type = None        self.order_status = OrderStatus.PENDING_NEW        self.strategy_id = None        self.is_in_order_done_state = False    def __str__(self):        return "OrderID=" + str(self.order_id) + \               ", Symbol=" + self.symbol + \               ", Side=" + str(self.side) + \               ", Quantity=" + str(self.quantity) + \               ", LeavesQty=" + str(self.leaves_qty) + \               ", FilledQty=" + str(self.filled_qty) + \               ", Price=" + str(self.price) + \               ", Total Amount =" + str(self.total_amount) + \               ", Avg Filled Price =" + str(self.avg_filled_price) + \               ", Timestamp=" + str(self.timestamp) + \               ", Order Type=" + str(self.order_type) + \               ", Order Status=" + str(self.order_status) +\               ", Strategy ID=" + str(self.strategy_id)# Instrument trading rulesclass InstrumentDetails:    def __init__(self, contract_name, tick_size, quantity_size=0):        self.contract_name = contract_name        self.tick_size = tick_size        self.quantity_size = quantity_size    def __str__(self):        return "Symbol=" + self.contract_name + \               ", Tick Size=" + str(self.tick_size) + \               ", Quantity Size=" + str(self.quantity_size)# Order eventclass OrderEvent:    def __init__(self, contract_name: str, order_id: str, execution_type: ExecutionType, status: OrderStatus, canceled_reason=None, client_id=None,order_type:OrderType=OrderType.Market):        self.contract_name = contract_name        self.order_id = order_id        self.client_id = client_id        self.execution_type = execution_type        self.status = status        self.canceled_reason = canceled_reason        self.order_type = order_type        # the following fields will be populated if matched        self.side = None        self.last_filled_time = None        self.last_filled_price = 0        self.last_filled_quantity = 0    def __str__(self):        return "Order event [contract={}, order_id={}, status={}, type={}, side={}, last_filled_price={}, last_filled_qty={}, canceled_reason={}]"\            .format(self.contract_name, self.order_id, self.status, self.execution_type, self.side, self.last_filled_price, self.last_filled_quantity, self.canceled_reason)    def __repr__(self):        return str(self)# A trade is an execution/fill by an exchangeclass Trade(Serializable):    def __init__(self, received_time: float, contract_name: str, price: float, size: float, side: Side,realized_pnl:float, liquidation: False):        self.received_time = received_time        self.contract_name = contract_name        self.price = price        self.size = size        self.side = side        self.liquidation = liquidation        self.realized_pnl = realized_pnl        self.order_id = ""    def is_buy(self):        return self.side == Side.BUY    def __str__(self):        return "OrderID=" + str(self.order_id) + \            ", Symbol=" + self.symbol + \            ", Side=" + str(self.side) + \            ", Price=" + str(self.price) + \            ", LeavesQty=" + str(self.leaves_qty) + \            ", Timestamp=" + str(self.timestamp) + \            ", Type=" + str(self.type) + \            ", Status" + str(self.order_status)